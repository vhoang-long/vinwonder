<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VinWonders</title>
    <link rel="icon" type="image/png" href="/assets/iconlogo.png" />
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
      integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      /* You can move these to style.css */
      body {
        margin: 0;
        font-family: Arial, sans-serif;
      }

      .map-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .map-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: #f77119;
        color: white;
        padding: 10px 16px;
        font-size: 18px;
      }


      .map-wrapper {
        position: relative;
        flex: 1;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #ffe2c5;
      }

      .map {
        max-height: 100%;
        width: auto;
        cursor: grab; /* show grab cursor when pannable */
        touch-action: none; /* allow pointer events for touch panning */
        will-change: transform;
        user-select: none; /* prevent text selection during drag */
      }

      .map.grabbing {
        cursor: grabbing;
      }

      /* Zoom buttons */
      .zoom-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .zoom-btn {
        background-color: #f77119;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 10px 14px;
        font-size: 18px;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .zoom-btn:hover {
        background-color: #ec6003;
      }
    </style>
  </head>

  <body>
    <div class="map-container">
      <div class="map-head">
        <a href="./index.html">
          <i class="fa-solid fa-arrow-left"></i>
        </a>
        <p>VinWonders Nha Trang</p>
        <div></div>
      </div>

      <div class="map-wrapper">
        <img
          id="mapImage"
          src="./assets/map.jpg"
          alt="VinWonders Nha Trang"
          class="map"
        />

        <div class="zoom-controls">
          <button class="zoom-btn" id="zoomIn"><i class="fa-solid fa-plus"></i></button>
          <button class="zoom-btn" id="zoomOut"><i class="fa-solid fa-minus"></i></button>
        </div>
      </div>
    </div>

    <script>
      const mapImage = document.getElementById("mapImage");
      const zoomInBtn = document.getElementById("zoomIn");
      const zoomOutBtn = document.getElementById("zoomOut");
      const wrapper = document.querySelector('.map-wrapper');

      let zoomLevel = 1; // initial scale (100%)
      let translateX = 0; // current translate in px
      let translateY = 0;

      // For dragging
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let startTx = 0;
      let startTy = 0;
      let dragMaxOffsetX = 0;
      let dragMaxOffsetY = 0;

      zoomInBtn.addEventListener("click", () => {
        zoomLevel = +(zoomLevel + 0.5).toFixed(2);
        // Enable transition for smooth zoom
        mapImage.style.transition = 'transform 0.3s ease';
        clampAndApply();
      });

      zoomOutBtn.addEventListener("click", () => {
        zoomLevel = Math.max(1, +(zoomLevel - 0.5).toFixed(2));
        if (zoomLevel === 1) {
          translateX = 0;
          translateY = 0;
        }
        // Enable transition for smooth zoom
        mapImage.style.transition = 'transform 0.3s ease';
        clampAndApply();
      });


      function applyTransform() {
        mapImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomLevel})`;
      }

      function clampAndApply() {
        // compute base (unscaled) size of image as it's rendered
        const wrapperRect = wrapper.getBoundingClientRect();
        // Get current rendered size of the image at scale=1 by temporarily resetting transform
        const prevTransform = mapImage.style.transform;
        mapImage.style.transform = 'translate(0px, 0px) scale(1)';
        const baseRect = mapImage.getBoundingClientRect();
        const baseWidth = baseRect.width;
        const baseHeight = baseRect.height;
        // restore previous transform
        mapImage.style.transform = prevTransform;

        const scaledWidth = baseWidth * zoomLevel;
        const scaledHeight = baseHeight * zoomLevel;

        // allowed offset from center (half the overflow amount)
        const maxOffsetX = Math.max(0, (scaledWidth - wrapperRect.width) / 2);
        const maxOffsetY = Math.max(0, (scaledHeight - wrapperRect.height) / 2);

        // clamp translateX/Y to [-maxOffset, maxOffset]
        translateX = Math.min(maxOffsetX, Math.max(-maxOffsetX, translateX));
        translateY = Math.min(maxOffsetY, Math.max(-maxOffsetY, translateY));

        // update cursor affordance
        if (zoomLevel > 1) {
          mapImage.style.cursor = 'grab';
        } else {
          mapImage.style.cursor = 'default';
        }

        applyTransform();
      }

      // Pointer-based drag (works for mouse and touch)
      wrapper.addEventListener('pointerdown', (e) => {
        // Ignore pointerdown events that originate from UI controls (zoom buttons)
        if (e.target.closest('.zoom-controls') || e.target.closest('button')) return;
        if (zoomLevel <= 1) return; // only pan when zoomed
        if (e.button && e.button !== 0) return; // left button only
        
        e.preventDefault(); // prevent default behavior
        isDragging = true;
        try { wrapper.setPointerCapture(e.pointerId); } catch (err) {}
        startX = e.clientX;
        startY = e.clientY;
        startTx = translateX;
        startTy = translateY;
        mapImage.classList.add('grabbing');
        
        // Disable transition during drag for immediate feedback
        mapImage.style.transition = 'none';

        // compute drag bounds once and cache for pointermove
        const wrapperRect = wrapper.getBoundingClientRect();
        const prevTransform = mapImage.style.transform;
        mapImage.style.transform = 'translate(0px, 0px) scale(1)';
        const baseRect = mapImage.getBoundingClientRect();
        mapImage.style.transform = prevTransform;
        const baseWidth = baseRect.width;
        const baseHeight = baseRect.height;
        const scaledWidth = baseWidth * zoomLevel;
        const scaledHeight = baseHeight * zoomLevel;
        dragMaxOffsetX = Math.max(0, (scaledWidth - wrapperRect.width) / 2);
        dragMaxOffsetY = Math.max(0, (scaledHeight - wrapperRect.height) / 2);
      });

      wrapper.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        e.preventDefault(); // prevent default behavior
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        translateX = startTx + dx;
        translateY = startTy + dy;
        // clamp during move using cached dragMaxOffsetX/Y
        translateX = Math.min(dragMaxOffsetX, Math.max(-dragMaxOffsetX, translateX));
        translateY = Math.min(dragMaxOffsetY, Math.max(-dragMaxOffsetY, translateY));
        // apply without transition for immediate feedback
        mapImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomLevel})`;
      });

      wrapper.addEventListener('pointerup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        try { wrapper.releasePointerCapture(e.pointerId); } catch (er) {}
        mapImage.classList.remove('grabbing');
        clampAndApply();
      });

      wrapper.addEventListener('pointercancel', (e) => {
        if (!isDragging) return;
        isDragging = false;
        try { wrapper.releasePointerCapture(e.pointerId); } catch (er) {}
        mapImage.classList.remove('grabbing');
        clampAndApply();
      });

      // initialize
      clampAndApply();
    </script>
  </body>
</html>
